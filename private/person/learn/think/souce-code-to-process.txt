源代码到进程的全生命周期过程分析
一、 编译（源代码转换为机器码的过程，或者中间代码）
二、 加载（机器码加载到内存，或者中间代码加载到虚拟机）
三、 进程（内存到CPU，各种调度，各种资源）

编译过程 
源代码通过编译器的输出成为可执行的二进制文件或者中间代码
首先编译器拿到源代码会进行词法分析,改过程会将C代码里面的宏定义精选转换，词法分
析过程中，会对关键字，将源代码中的表达式进行词分，若是源代码中少分号，关键字写
错了等错误在此过程中可以发现。在词法分析的基础上编译器进行语法分析，语法分析过
程会将注释和空白进行处理，多余的空行和注释会被删除，对程序的单行语法结构进行规
则校验，进行推到，此时源代码被处理成编译器解析成一种编译器可以阅读的抽象语法树，然后在此基
础上进行语义分析，即源代码整体上下文是否有语法错误，是否符合上下文语义，此时编
译器结合当前目标系统对确定的每句表达式，每个变量，进行翻译生成中间树，并对函数
和变量的分配情况进行记录，分配。此时源代码被处理成为与语言无关目标机器体系结构
无关的抽象机器中间代码，然后编译器依据抽象机器中间代码树进行翻译，翻译为对应的
机器代码，在此过程中会存在一条抽象代码对应一条机器代码情况，此类情况是最好
处理的，直接可以快速的翻译为机器语言，若是存在一条抽象代码对应多条机器指令的情
况，而正常情况下一对多的情况比较常见，所有此时需要编译器对指令的翻译进行选择，
此过程中编译器会对源代码进行优化，依据不同的优化策略进行，范围内的最优翻译。编
译器的选择只能尽可能的正确，不能保证翻译成最优的代码，在语义特别模糊的极端情况
下不同的编译器有不同的策略，某些不够智能的编译器无法生存最优的代码，更胜某些个
别的编译器个别版本会曲解源代码的语义将一些代码进行优化，一些代码进行展开，结构
反而悲剧了生成错误的机器指令，如VC6，所以有些高手写代码里面有各种宏定义，那些
地方主要是针对不同平台，不同编译器版本生成最优的代码处理策略，在C里面，若是要
写出最高效的代码，不但需要考虑是否方便移植，还得考虑不同的编译器版本，一般正常
情况下面，源代码不要针对编译器进行过多的优化，不要过多的使用过多的特定编译器特
性，像很多GCC的一些特性在其他编译器版本里面是相当激进的特性，若不是特殊场景下
尽量不要使用这些特性，像nginx里面那样多使用写特定平台的特定属性进行优化是推荐
使用的，接下来编译器将生成二进制的可执行文件，此过程中编译器会对寄存器的需求进
行分配，代码里面没有显示声明需要使用寄存器的地方，该变量在该流程中大量长期使用
的情况下面，编译器自动给分配寄存器，以优化程序执行效率，为每个确定的流程标号分
配相对地址，地址是相对的，需要在程序加载的时候进行相对转换。

加载过程
Linux/Unix 下面执行程序一般都是由shell启动，shell启用新进程的最常见的系统调用
是sys_fork,Linux fork出来的进程基本上是写时复制的，因此大致过程是内核为新进程
分配一个在进程链表上的空位和唯一的PID，然后调用copy_process将父进程结构复制一份给
新子进程，更新PID，更新新进程的进程结构，此时进程处于内核运行态，此时创建的新
进程并没有对应任何的具体可执行程序，新进程调用execve()加载可执行程序，此时若是
可执行程序不存在内核无法加载文件将报错，然后会对可执行文件是否存在执行权限检查
若是当前用户无执行权限将报permission denied错误，接着会判断可执行文件的类型，
常见的是elf和shell类型，若为elf类型条用load_elf_binary 函数加载可执行程序，elf
文件header部分被加载到elf结构体中，新进程若是立即执行，内核调用mmap对elf文件中
各段进行内存映射，数据分段分页映射，当进程执行该进程时引发虚拟地址到逻辑地址缺
页中断，此时数据才被调度加载到内存中，若是可执行文件中包含动态库的引用，先会调
用ld加载到一个内存地址，在函数没有被执行时动态库的数据是不会加载到物理内存中的，
只有被执行到是发生缺页错误此时动态库才内调用加载到内存中，但是有一种特殊的情况，
是显示控制动态库的载入载出，dlopen和dlfree 一般情况下动态库加载进入内存一直到
进程结束都会占用内存空间，若是该库用的比较频繁一直存在内存中是不错的选择，但是
若是存在某种库占用内存奇大且整个进程生命周期中仅被调用一次，那个可以选择显示的
载入执行结束后在free掉，节约内存空间。

进程过程
主要是进程的调度，内存管理，资源的分配等过程
时下大部分系统都是多任务系统，CPU的每个核心在一时间片上只能执行一条指令，因此
内核将进程对CPU的需求切分成多个CPU时间片刻，每个进程只能轮流使用单位上时间片刻
的CPU，然后被内核调度给其他进程使用。
Linux进程有优先级的概念，按照优先级优先调度进程使用CPU，一般的进程分为实时进程和普通进程两类，Linux系统实现的
是软实时，当实时进程处于可执行状态时内核会尽量的满足实时进程的CPU需求，若是所
有的实时进程使用CPU时间片超过系统的上限值将被内核调度CPU给普通进程使用，防止普通进程得
不到CPU使用。同类型的实时进程常见有两种调度策略先来先得和轮转调度。普通进程间
也有有优先级的概念，Linux系统对与普通进程的调度策略是尽量保证每个进程公平合理
高效的使用CPU时间，因此普通进程的优先级是动态的。被抢占的进程优先级可能会被降
低，长期没有获取到CPU时间的进程优先级会被提高。
Linux进程看到的内存地址是线性的连续的4G（32位）地址，进程管理的内存是虚拟的，
进程看到的0-4G的地址，一般0-3G是用户地址空间，3-4G是内核空间，3-4G是系统的调用
地址，全局上是相同的，0-3G用空间从进程角度上来看，一般分为代码段，数据段，BSS
段，堆段，栈段。代码段是存放指令代码的需要只读，因此单独存放，内核进行写保护，
BSS段是未初始化的全局变量，依据C标准的规定未初始化的全局变量值为0，BSS段下面是数据
段，数据段存放的是已经初始化的全局变量，BSS段上是堆段，堆段是动态分配的内存空，
一般是向上增长的，堆段上方是栈段，栈段是临时变量的内存空间，如函数内的变量等等，
栈段是向下增长的，栈与堆之间空隙很大基本上不会重叠的。进程管理的内存实质上是逻
辑上的内存只是连续的地址，不是物理上的内存，进程的内存分配映射对于的内核虚拟内
存地址，因此进程使用的内存地址每次都可以是固定的，虽然进程使用的是虚拟内存地址，
但是CPU每次读写的看到的内存地址是物理上的内存地址（不能叫真正的物理地址，只是相对进程的虚
拟地址），内核管理的内存地址是4k一页大小的物理内存地址，内核按照页对内存进行管
理，当进程malloc了一个2048的内存大小，内核并不会立刻存系统内存链表上门切两页给
进程使用，而是让进程自己先分配2048的内存完，等到CPU进行写数据或者读数据操作是，
内核才给进程感觉切两页大小出来，若是当且有够用连续内存分配内核就给连续的内存地
址映射给进程（进程自己看到的是连续的2048大小的内存），若是当前系统内存紧张没有
需求这样大小的连续内存，内核就凑两页大小内存映射给进程，若是连凑都凑不出来，那
内核就将不常用的内存置换到虚拟内存中（磁盘，swap）收集出来，然后映射给进程使用。
一般情况下内核不会立即将硬盘的数据放到内存中供进程使用只有当CPU正真访问到该块
物理内存时产生缺页中断时，内核才将磁盘的数据放到内存中，采用的机制是将内存分配
到不能再延后的策略。
内核将虚拟内存到物理内存的映射是通内存页表来查表映射的，内核对内存的管理是复杂
的，内核的内存调度也是复杂的，正常进程结束后或Free后会释放内存空间，该是否不是真正意义上的释
放内存，只是将进程的虚拟线性地址释放出来，系统上调用的是 unmmap，从内核的角度
来看内存仍然占用着，当下次访问的时候，就不需要产生缺页中断将数据从磁盘加载到内
存中，因此Linux内存基本上有多少吃多少通常第二次执行程序要比第一执行快。


